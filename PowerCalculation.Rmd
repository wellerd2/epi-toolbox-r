Step 0 — Decide what you’re powering up (i.e., your inputs)

We need 4 things (everything else is derived):
1. n_house = number of households (start with 30; also try 40, 50, 60…)
2. n_visits = 6
3. p0 = baseline positivity in the “cold” season. Let's 0.40 as a starting point.
4. OR = the smallest seasonal effect you care about detecting. We can use 1.5, 2, and 3 as a small, moderate and large effect
5. sd_house = how clustered results are within a household (random intercept SD)

## Option 1
```{r}
library(lme4)

# install.packages("geepack")
library(geepack)

simulate_power_gee <- function(
        n_house = 30,      # number of households (clusters)
        n_visits = 6,      # repeated samples per household (every other month)
        p0 = 0.40,         # baseline positivity in reference season (warm = 0; e.g., winter)
        OR = 2.0,          # winter vs summer odds ratio you want to be powered to detect
        sd_house = 1.0,    # random-intercept SD used ONLY to generate within-household correlation
        nsim = 1000,       # number of Monte Carlo simulations used to estimate power
        alpha = 0.05,      # significance threshold
        seed = NULL
){
    if (!is.null(seed)) set.seed(seed) # optional reproducibility
    
    warm <- rep(c(0,0,0,1,1,1), length.out = n_visits) 
    # 3 winter (0), 3 summer (1); this defines your seasonal exposure pattern
    
    b0 <- qlogis(p0)  
    # intercept on log-odds scale; your baseline prevalence is your intercept
    
    b1 <- log(OR)     
    # seasonal effect on log-odds scale; this encodes the minimum seasonal difference you want to detect
    
    sig <- logical(nsim) 
    # stores whether the seasonal effect was statistically significant in each simulation
    
    for (s in seq_len(nsim)) {
        
        u <- rnorm(n_house, 0, sd_house)  
        # generates household-specific random intercepts
        # this creates realistic within-household correlation in the simulated data
        
        id <- rep(seq_len(n_house), each = n_visits) 
        # cluster ID variable (which household each sample belongs to)
        
        warm_i <- rep(warm, times = n_house) 
        # 0/1 seasonal indicator for each observation
        
        eta <- b0 + 
            b1 * warm_i + 
            u[id]  
        # linear predictor on log-odds scale:
        # baseline log-odds + seasonal shift + household-specific shift
        
        y <- rbinom(n_house * n_visits, 1, plogis(eta)) 
        # converts log-odds to probability (via plogis),
        # then simulates binary outcomes (0/1 contamination)
        
        dat <- data.frame(y = y, warm = warm_i, id = id)
        
        fit <- suppressWarnings(
            geeglm(
                y ~ warm, 
                id = id, 
                data = dat, 
                family = binomial, 
                corstr = "exchangeable"
            )
        )
        # fits population-averaged logistic regression using GEE
        # exchangeable correlation assumes constant correlation within household
        # no random-effect variance is estimated (more numerically stable than glmer)
        
        pval <- summary(fit)$coefficients["warm", "Pr(>|W|)"]
        # extracts Wald test p-value for seasonal effect
        
        sig[s] <- (!is.na(pval)) && (pval < alpha)
        # records whether the seasonal effect was detected at the chosen alpha
    }
    
    mean(sig) 
    # estimated power = proportion of simulations where season was significant
}
```

4A) Vary the seasonal effect
```{r}
set.seed(1)
simulate_power(n_house = 30, p0 = 0.40, OR = 2, sd_house = 1.0, nsim = 1000)
```

4B) Vary clustering (sd_house)
```{r}
simulate_power(n_house = 30, p0 = 0.40, OR = 2, sd_house = 0.5, nsim = 1000)
simulate_power(n_house = 30, p0 = 0.40, OR = 2, sd_house = 1.0, nsim = 1000)
simulate_power(n_house = 30, p0 = 0.40, OR = 2, sd_house = 1.5, nsim = 1000)
```

4C) Vary households (this is your “sample size curve”)
```{r}
simulate_power(n_house = 30, p0 = 0.40, OR = 2, sd_house = 1.0, nsim = 1000)
simulate_power(n_house = 40, p0 = 0.40, OR = 2, sd_house = 1.0, nsim = 1000)
simulate_power(n_house = 50, p0 = 0.40, OR = 2, sd_house = 1.0, nsim = 1000)
simulate_power(n_house = 60, p0 = 0.40, OR = 2, sd_house = 1.0, nsim = 1000)
```

## Option 2
```{r}
min_households_for_power <- function(
  target_power = 0.80,  # desired power (e.g., 0.80)
  n_visits = 6,         # repeats per household (your design: 6 visits)
  p0 = 0.40,            # baseline positivity in "winter"/cold (reference season, warm=0)
  OR = 2.0,             # winter vs summer odds ratio you want to be powered to detect
  sd_house = 1.0,       # household random-intercept SD (tunes within-household correlation)
  alpha = 0.05,         # significance threshold for calling "detected"
  nsim = 1000,          # Monte Carlo iterations used to estimate power at each n_house
  n_min = 10,           # smallest n_house to consider
  n_max = 200,          # largest n_house to consider
  step = 5,             # step size for coarse search (e.g., 5-household increments)
  verbose = TRUE        # print progress as it searches
){
  results <- data.frame(n_house = integer(), power = numeric()) # stores (n_house, estimated power) across search grid

  for (n in seq(n_min, n_max, by = step)) { # coarse grid search over candidate household counts
    pow <- simulate_power(
      n_house = n, n_visits = n_visits, p0 = p0, OR = OR, sd_house = sd_house,
      nsim = nsim, alpha = alpha) # estimated power for this candidate n_house under your assumed p0/OR/sd_house

    results <- rbind(results, data.frame(n_house = n, power = pow)) # append to results table

    if (pow >= target_power) { # once coarse grid hits target power, refine to find the minimum n_house
      if (step > 1) { # refinement only makes sense if coarse grid step was > 1
        n_start <- max(n_min, n - step + 1) # go back to the start of the last step window
        for (n2 in seq(n_start, n, by = 1)) { # fine search in single-household increments to find the true minimum
          pow2 <- simulate_power(
            n_house = n2, n_visits = n_visits, p0 = p0, OR = OR, sd_house = sd_house,
            nsim = nsim, alpha = alpha) # power at n2 (same assumptions; just varying households)

          results <- rbind(results, data.frame(n_house = n2, power = pow2)) # keep refined values too

          if (verbose) message(" refine: n_house = ", n2, " -> power = ", round(pow2, 3)) # progress print for refinement

          if (pow2 >= target_power) return(list(min_n_house = n2, results = results)) # first n2 that hits target = minimum
        }
      }
      return(list(min_n_house = n, results = results)) # if no refinement (step==1), n is already the minimum found
    }
  }

  list(min_n_house = NA, results = results) # if target_power never reached up to n_max, return NA + the attempted grid
}
```

```{r}
out <- min_households_for_power(
  target_power = 0.80,
  n_visits = 6,
  p0 = 0.40,
  OR = 2,
  sd_house = 1.0,
  nsim = 500,    
  step = 5,
  n_max = 150)

out$min_n_house
tail(out$results[order(out$results$n_house), ], 10)

```

